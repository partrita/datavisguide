---
title: 시각화의 원칙과 요소
format:
  html:
    code-fold: true
    code-tools: true
  pdf: default
execute: 
  warning: false
  eval: false
  echo: true
editor: source
---

데이터 시각화는 목적을 충족해야 합니다. 시각화의 목적을 이해함으로써 우리(저자 또는 독자로서)는 시각화가 목표를 달성했는지 아니면 개선이 필요한지를 평가할 수 있는 위치에 서게 됩니다!

아마도 시각화의 가장 일반적인 목적은 서로 다른 치료를 받는 환자 데이터와 같이 데이터 그룹을 비교하는 것입니다. 축, 축 제한, 레이블 및 기호를 잘 선택하면 데이터의 패턴을 식별하는 데 상당히 도움이 되지만, 이러한 요소 중 하나라도 잘못 선택하면 정보 추출을 상당히 방해할 수 있습니다.

## 차트의 요소

시각화의 다양한 요소는 정보를 추출하는 효율성에 기여할 수 있습니다. 모든 시각화 소프트웨어 패키지는 기본 스타일로 그래픽을 출력하지만, 이것이 여러분이 만들고 있는 데이터 시각화에 대한 최적의 선택인 경우는 드뭅니다. 데이터 시각화를 디자인할 때는 사용 가능한 다양한 옵션을 고려해야 합니다. 이러한 옵션 중 일부는 다음과 같습니다.

### 레이아웃 (패널, 패싯)

레이아웃(여러 패널, 패싯 또는 서브플롯의 배열)은 효율적인 비교와 매우 관련이 있습니다. y축 데이터를 비교해야 하는 경우 모든 패널을 수평으로 정렬하여 단일 y축을 사용하는 것이 비교를 용이하게 하는 반면, x축 값을 효율적으로 비교하려면 패널을 쌓아야 합니다. 매트릭스 레이아웃(단일 그림에 여러 행과 열)은 개별 패널에 표시된 데이터가 관련이 없거나 공간이 단일 행 또는 단일 열을 허용하지 않는 경우(예: 패널이 너무 많아 한 행에 맞지 않는 경우)에만 사용해야 합니다.

**예:** 아래 그림은 레이아웃을 제외하고는 정확히 동일한 데이터와 정확히 동일한 유형의 시각화를 보여주는 두 가지 다른 레이아웃을 보여줍니다. 왼쪽 패널의 데이터를 비교하는 것이 얼마나 어려운지, 반면 오른쪽 레이아웃에서는 얼마나 쉬운지 주목하십시오. 핵심 차이점은 오른쪽 패널이 공통 y축을 공유한다는 것이며, 이는 패널 간의 y값 비교에 핵심적입니다.

```{r}
# ---
# Data set creation.

set.seed(93384)

time <- c(0, 0.5, 1, 2, 4, 8, 12, 16, 24)
n <- 32 # no of subjects

data <- expand.grid(ID = 1:n, time = time)

bw <- data.frame(
  ID = sort(unique(data$ID)),
  bw = rlnorm(n, log(75), sdlog = 0.25)
)

bw$bw.category <- cut(bw$bw,
  breaks = quantile(bw$bw, c(0, 0.33, 0.66, 1)),
  labels = paste(c("low", "medium", "high"), "body weight"),
  include.lowest = TRUE
)

data <- merge(data, bw)

data <- data[order(data$ID, data$time), ]

# Simulate drug concentrations as a function of body weight.
data$conc <- 100 / (data$bw^1.0) * exp(-0.085 * data$time) *
  rlnorm(nrow(data), sdlog = 0.25) + # res. error
  (data$ID - mean(data$ID)) / mean(data$ID) / 4 # r. eff

# ---
# Visualisation.
library(ggplot2)

gg <- list()

data$ID <- factor(data$ID)

gg[["3x1"]] <- ggplot(data, aes(x = time, y = conc, group = ID, color = ID)) +
  geom_line()
gg[["3x1"]] <- gg[["3x1"]] + scale_x_continuous(breaks = seq(0, 24, by = 4))
gg[["3x1"]] <- gg[["3x1"]] + theme_bw() + 
  xlab("time [h]") + 
  ylab("drug concentration [ng/mL]")
gg[["3x1"]] <- gg[["3x1"]] + facet_grid(bw.category ~ .)
gg[["3x1"]] <- gg[["3x1"]] + theme(legend.position = "none")

gg[["1x3"]] <- gg[["3x1"]] + facet_grid(. ~ bw.category)

# Add space to the rhs of the first figure for better separation in the cowplot.
gg[["3x1"]] <- gg[["3x1"]] + 
  theme(plot.margin = unit(c(0.5, 4, 0.5, 0.5), "lines"))

# Both figures into a single output figure.
library(cowplot)
plot_grid(gg[[1]], gg[[2]], rel_widths = c(1.5, 2))
```

[![레이아웃 선택이 패널 간 비교 용이성을 결정하는 방식을 보여주는 선 도표. 왼쪽 패널은 세로로 쌓인 3개의 플롯을 보여줍니다. 오른쪽 패널은 가로로 배열된 동일한 3개의 플롯을 보여줍니다.](images/principles-layout.png){fig-alt="레이아웃 선택이 패널 간 비교 용이성을 결정하는 방식을 보여주는 선 도표. 왼쪽 패널은 세로로 쌓인 3개의 플롯을 보여줍니다. 오른쪽 패널은 가로로 배열된 동일한 3개의 플롯을 보여줍니다."}](images/principles-layout.png)

### 종횡비 (Aspect ratio)

디스플레이에서 데이터에 대한 시각적 인식은 x축과 y축의 선택에 의존해서는 안 됩니다. 많은 경우 정사각형 그림은 시각적 편향을 방지합니다. 특히 두 축이 어떤 사건 전후의 측정, 관측 데이터 대 모델 예측 값, 또는 더 일반적으로 동일한 단위(kg 또는 m 등)와 같은 공통점을 공유하는 경우 정사각형 그림을 고려해야 합니다. 일반적으로 1:1 종횡비(x 방향과 y 방향에서 1 측정 단위의 물리적 길이)가 좋은 기본값입니다. 그림이 x축과 y축에 대해 동일한 범위를 갖는 경우 1:1 종횡비는 정사각형 그림을 산출합니다.

**예:** 아래 세 패널은 모두 동일한 데이터를 보여주며, 모델 적합도(예측 값 대 관측 값)에 대한 판단을 가능하게 하는 것을 목표로 합니다. 늘어난 x축, 늘어난 y축, 그리고 동일한 축 제한을 가진 1:1 종횡비 간의 시각적 인식 차이에 주목하십시오.

```{r}
#| message: false
#| warning: false
# Observed vs predicted (any data with comparable x and y will do).

# ---
# Data set.
# Old Faithful Geyser (Yellowstone) data set with eruption duration
#   and waiting time to the next eruption (both in minutes).
data <- data.frame(
  x = faithful$eruptions,
  y = faithful$waiting
)

# ---
# Regression model fit.
fit <- lm(y ~ x, data = data)

# Addition of predicted values to the data set.
data$pred <- predict(fit)

# Range of y and y predicted combined.
r <- range(unlist(data[c("y", "pred")]))

# ---
# Plotting.

library(ggplot2)

gg <- ggplot(data, aes(x = pred, y = y))

# Adding the line of identity, y = x
# (note: plotting it first will add points on top).
gg <- gg + geom_abline(intercept = 0, slope = 1, color = "black", linewidth = 1)

# Adding points, removing grey background.
gg <- gg + geom_point() + theme_bw()

# Adding regression fit (local smoother, loess) of y~x.
gg <- gg + geom_smooth(method = "loess", color = "firebrick", se = FALSE)

# Adding axis labels.
gg <- gg + xlab("predicted") + ylab("observed")

# Aspect ratios are commonly not fixed but adapted to figure size.
#   With dynamic displays, the point of different perception
#   might not be obvious depending on the figure/screen size.
#   To make that point independent of figure height and width,
#     the aspect ratio is fixed in this example.
gg <- gg + coord_fixed(ratio=0.5)

# Copy the figure and fix the aspect ratio to 2, i.e., 
#   one pixel in x corresponds to 2 pixels in y.
gg2 <- gg + coord_fixed(ratio=2)

# Setting the aspect ratio to 1 (1 unit in x and y 
#   corresponds to the same number of pixels) and 
#   setting axis limits to be identical.
gg3 <- gg + coord_fixed(ratio=1, xlim=r, ylim=r)

# Cow (column-wise) plot, combine all figures into one.
library(cowplot)
plot_grid(gg, gg2, gg3, rel_widths = c(4, 2, 3), nrow = 1)
```

[![모델 적합도에 대한 시각적 인식이 종횡비에 의해 어떻게 영향을 받을 수 있는지 보여주는 산점도.](images/principles-aspect-ratio.png){fig-alt="모델 적합도에 대한 시각적 인식이 종횡비에 의해 어떻게 영향을 받을 수 있는지 보여주는 산점도. 왼쪽 패널은 늘어난 x축을 가지고, 가운데 패널은 늘어난 y축을 가지며, 오른쪽 패널은 동일한 축 제한을 가진 1:1 종횡비를 가집니다."}](images/principles-aspect-ratio.png)

### 선 (Lines)

선은 순서, 즉 시퀀스를 도입합니다. 순서가 없는 경우 데이터는 선으로 서로 연결되어서는 안 됩니다. 다른 선 유형이 고유한 순서를 가진 다른 그룹을 나타내는 경우, 선택한 선 스타일도 순서를 갖는 것이 좋습니다(예: 가장 낮은 그룹에서 가장 높은 그룹으로 갈수록 선 두께, 대시 밀도 또는 색상의 어두움이 증가함).

### 점 (Points)

점 기호는 시각화가 데이터를 의미 있는 방식으로 표시하도록 선택해야 합니다. 수천 개의 데이터 포인트를 표시해야 하는 경우, 겹치는 채워진 기호보다 열린 원이나 더 작은 채워진 기호가 더 좋습니다. 데이터가 이산적이고 관측치가 겹치는 경우 더 나은 시각화를 위해 데이터를 부드럽게 지터링(jittering)하는 것을 고려하십시오.

### 색상 (Colours)

색상은 서로 다른 그룹을 식별하는 데 도움을 주는 것과 같은 목적을 수행해야 합니다. 순수 장식용 색상은 권장하지 않습니다. Tufte는 "색상은 자연스러운 시각적 계층 구조를 가지고 있기 때문에 다양한 회색 음영이 색상보다 다양한 양을 더 잘 보여준다"며 "회색 음영은 데이터 측정에 쉽게 이해되는 순서를 제공한다. 이것이 핵심이다"라고 지적했습니다 [@Tufte2001, p. 154].

### 축 (Axes)

#### 원점 및 제한

다른 범위를 선택할 타당한 이유가 없는 한 축 범위는 일반적으로 0에서 시작해야 합니다. 데이터에 음수 값이 포함되지 않은 경우 축은 음수 값으로 뻗어 나가서는 안 되며 특히 음수 값에 눈금을 표시해서는 안 됩니다.

상대적인 변화나 비율이 표시되는 경우 해당 축은 로그여야 하며(예: 1/4이 기준점 1까지의 거리가 4와 같도록), 변화 없음 지점을 중심으로 대칭이어야 합니다. 변화 없음 지점에 보조선을 그으면 해석이 쉬워집니다. 축 눈금과 보조 회색 선은 값을 읽는 것을 용이하게 하여 보는 사람이 잘못된 선형 보간을 하는 것을 방지합니다. 축 눈금 레이블은 비율을 나타내야 합니다(예: 0.25 대신 "1/4").

x와 y로 표시되는 데이터가 비교 가능한 경우 축 제한은 동일해야 하며 그림은 정사각형이어야 하므로 x 방향과 y 방향의 거리가 일관되어야 합니다.

**예:** 아래 그림은 의도적인 축 제한 선택(여기서는 y축 제한)이 인식에 큰 차이를 만들 수 있으며, 따라서 독자의 해석에도 큰 차이를 만들 수 있음을 보여줍니다. 두 패널의 유일한 차이점은 y축 범위입니다.

```{r}
library(ggplot2)
plot_data <- data.frame(
  type = factor(
    c("Our product", "Competitor"),
    levels = c("Our product", "Competitor")
  ),
  value = c(220, 210)
)

# Original plot
ggplot(plot_data) +
  geom_col(
    mapping = aes(x = type, y = value),
    fill = "lightblue",
    colour = "black"
  ) +
  scale_y_continuous(breaks = seq(0, 220, by = 20), expand = c(0, 0)) +
  labs(x = "", y = "") +
  theme_minimal()

# Offset the y axis
offset <- 208
ggplot(plot_data) +
  geom_col(
    mapping = aes(x = type, y = value - offset),
    fill = "lightblue",
    colour = "black"
  ) +
  scale_y_continuous(
    breaks = seq(0, 14, by = 2),
    labels = seq(0 + offset, 14 + offset, by = 2),
    expand = c(0, 0)
  ) +
  labs(x = "", y = "") +
  theme_minimal()
```

[![축 제한의 선택에 의해 시각적 인상이 어떻게 좌우될 수 있는지 보여주는 막대 차트.](images/principles-axes.png){fig-alt="축 제한의 선택에 의해 시각적 인상이 어떻게 좌우될 수 있는지 보여주는 막대 차트. 왼쪽 패널 차트는 y축이 0에서 시작하고, 오른쪽 패널은 y축이 208에서 시작하여 두 막대 사이의 작은 10단위 차이를 과장이 있습니다."}](images/principles-axes.png)

#### 선형 및 로그 축

**예:** 어떤 변수 y가 다른 변수 x에 따라(참조 또는 기준 측정과 비교하여) 변하는지 알고 싶다고 가정해 봅시다. 예를 들어, 혈압이 치료에 따라 변하는가?

아래 그림은 참조(기준) 측정과 비교하여 평균적으로 변화가 없는 데이터(빨간색 가로선, 상단 두 패널)를 보여줍니다. 데이터의 약 절반은 변화 없음 지점 아래에 있고 나머지 절반은 위에 있습니다. 그러나 선형 축을 사용하는 왼쪽 상단 패널에서는 이것이 쉽게 드러나지 않으며 공간은 참조선에서 멀어지는 수직 방향(위아래 모두)으로 비대칭적으로 할당됩니다. 로그 축을 사용하는 오른쪽 상단 패널에서는 참조선 주위에 데이터 포인트가 비교적 고르게 퍼져 있는 것을 명확하게 볼 수 있습니다. 아래쪽 행에서는 동일한 데이터가 다시 선형 및 로그 축을 사용하여 히스토그램 형식으로 표시됩니다.

```{r}
# Naïve plot of y vs x. If there is no change (on average),
# half the data are below the line of no change.
# Asymmetric view, and it depends on y/x or x/y.

set.seed(33838)
x <- data.frame(
  x = rlnorm(200, 2, 0.2),
  y = rlnorm(200, 0.2, 0.75)
)
# Add an outlier manually.
x <- rbind(x, data.frame(x = quantile(x$x, 0.8), y = max(x$y) * 1.5))

# ---
# Plotting.

library(ggplot2)
# Scatterplot of y vs x.
gg <- ggplot(x, aes(x = x, y = y)) +
  geom_point() +
  theme_bw()
gg <- gg + geom_hline(yintercept = 1, color = "firebrick", linewidth = 2)
gg <- gg + xlab("x-variable") + ylab("Fold-change")
gg
# Logarithmic axes, symmetric range (!):
xbr <- c(1 / 10, 1 / 5, 1 / 2, 1, 2, 5, 10)
gg <- gg + scale_y_continuous(
  breaks = xbr, trans = "log10",
  limits = max(abs(x$y))^c(-1, 1)
)
gg

# Second axis:
gg <- gg + scale_y_continuous(
  breaks = xbr,
  labels = paste(100 * xbr, "%", sep = ""),
  trans = "log10",
  limits = max(abs(x$y))^c(-1, 1),
  sec.axis = sec_axis(
    trans = ~ . * 1, breaks = xbr,
    labels = ifelse(xbr < 1, paste("1/", 1 / xbr, sep = ""), xbr)
  )
)

# ---
# Univariate distribution (histogram).

gg <- ggplot(x, aes(x = y)) +
  theme_bw() +
  xlab("Fold-change")
gg <- gg + geom_histogram(color = "firebrick", fill = "gray")
gg

# Symmetric range, log scale.
gg <- gg + scale_x_continuous(
  breaks = xbr,
  labels = ifelse(xbr < 1, paste("1/", 1 / xbr), xbr),
  trans = "log10",
  limits = max(abs(x$x))^c(-1, 1)
)
gg
```

[![선형 축(왼쪽)에서 로그 축(오른쪽)으로 전환하면 일부 기준 측정에 대한 값의 변화를 명확히 하는 데 도움이 됩니다.](images/principles-log.png){fig-alt="선형 축에서 로그 축으로 전환하면 일부 기준 측정에 대한 값의 변화를 명확히 하는 데 도움이 됩니다. 맨 윗줄에는 두 개의 산점도가 있으며 기준 값은 빨간색 가로 키라인으로 표시되어 있습니다. 왼쪽 상단 패널은 선형 축에 있는 반면, 오른쪽 상단 패널은 로그 축에 있으며 기준선 주위에 데이터 포인트가 고르게 퍼져 있음을 더 명확하게 보여줍니다. 맨 아랫줄에는 동일한 데이터가 히스토그램 형식으로 표시되어 있으며, 다시 왼쪽에는 선형 축, 오른쪽에는 로그 축이 있습니다."}](images/principles-log.png)

### 기호 (Symbols)

기호는 직관적이어야 합니다(예: 긍정적 결과는 "+", 부정적 결과는 "--", 중립적 결과는 "O"). 이상적인 경우, 기호는 범례를 한 번만 봐도 이후 시각화에 집중할 수 있어야 합니다.

삼각형, 원, 사각형과 같은 기호는 직관적인 함축적 의미를 갖지 않습니다. 그러나 데이터에 순서가 있는 경우 기호의 순서(예: 꼭짓점 수(원, 대시, 삼각형, 사각형, 오각형 등))에 반영될 수 있습니다.

### 범례 (Legends)

범례는 너무 많은 주의를 끌어서는 안 되며 데이터를 가려서는 절대 안 됩니다. 그림의 여백에 배치하거나 그림 아래에 작은 텍스트로 캡처할 수 있습니다.

범례 항목이 단일 객체(예: 그룹당 한 줄)를 참조하는 경우 범례를 해당 객체 옆에 배치하면 독자가 범례 항목을 디스플레이 객체에 매핑하기가 더 쉬워집니다.

**예:** 아래 그림은 해당 데이터 옆에 그림에 직접 범례를 추가하여 가독성을 높일 수 있음을 보여줍니다. 레이블은 겹치지 않아야 하며 레이블 위치는 데이터에 따라 조정이 필요할 수 있습니다.

```{r}
# ---
# EU stock markets, year and indices DAX, SMI, CAC, and FTSE.

# Store graphics into a list.
gg.list <- list()

# Prepare the data set (reformat EuStockMarkets that comes with R).
x <- EuStockMarkets
df <- data.frame(
  time = as.vector(time(x)),
  index = rep(colnames(x), rep(nrow(x), ncol(x))),
  value = as.vector(x),
  stringsAsFactors = TRUE
)
df$index2 <- df$index # For use with labels later.

library(ggplot2)

# Standard layout and legend.
gg <- ggplot(df, aes(x = time, y = value, group = index, color = index, label = index2))
gg <- gg + geom_line() + theme_bw()

# Nicer axis tick mark settings.
ax <- pretty(df$time, n = 10)
gg <- gg + scale_x_continuous(limits = range(ax), breaks = ax)
gg <- gg + xlab("year") + ylab("Stock index")

gg.list[[1]] <- gg

# Use the last element of each time series for x,y of the label.
# Use that the last element is the first element of the reversed order,
#   and extract the first element per index by using !duplicated.
y <- df[rev(order(df$time)), ] # descending in time.
y <- y[!duplicated(y$index), ] # first entry per index
y$index2 <- y$index # Create a copy that contains formatted strings.
levels(y$index2)[levels(y$index2) == "FTSE"] <- "\n\nFTSE"
# Add a newline to separate FTSE from DAX.
# Note that the factor level is modified, not the data.

# Drop the legend, move labels into figure.
gg <- gg + geom_text(data = y, hjust = "left", nudge_x = 0.1)
# aes as before, nudge adds space on the lhs.
gg <- gg + theme(legend.position = "none")
gg.list[[2]] <- gg

# ---
# Both figures into a single output figure.

library(cowplot)
plot_grid(gg.list[[1]], gg.list[[2]], rel_widths = c(2.25, 2))
```

[![그림 요소에 직접 레이블을 지정하면 가독성이 어떻게 향상될 수 있는지 보여주는 선 도표.](images/principles-legends.png){fig-alt="그림 요소에 직접 레이블을 지정하면 가독성이 어떻게 향상될 수 있는지 보여주는 선 도표. 왼쪽 패널은 다른 색상의 선을 식별하기 위해 범례를 사용합니다. 오른쪽 패널은 각 줄 끝에 그림 내 레이블을 포함합니다."}](images/principles-legends.png)

### 방향 (Orientation)

예를 들어 막대 그래프로 시각화해야 할 순서가 데이터에 있는 경우, 데이터를 가로 막대로 표시하고 위에서 아래로(가장 높은 값에서 가장 낮은 값으로) 정렬하는 것이 세로 막대를 왼쪽에서 오른쪽 방향으로 표시하는 것보다 더 직관적입니다[@Few2004, p. 182]. 이에 대한 일반적인 예외는 데이터를 시간 단위에 따라 정렬해야 하는 경우입니다. 시간은 종종 과거에서 현재, 미래로, 왼쪽에서 오른쪽으로 흐르는 것으로 시각적으로 해석됩니다.

예를 들어 상자 그림의 경우 가로 방향이 세로 방향보다 더 정확한 시각적 비교가 가능합니다. 아래 그림에서 볼 수 있듯이 인간의 눈은 가상의 수평선보다 가상의 수직선을 따라가기가 더 쉽기 때문입니다. 또한 왼쪽 패널에서는 긴 x축 레이블이 겹쳐서 읽을 수 없지만 오른쪽 패널에서는 가로 방향으로 읽을 수 있습니다.

```{r}
# Store figures into a list.
gg.list <- list()

library(ggplot2)

x <- mpg # miles per gallon data set.
x$car <- paste(x$manufacturer, x$model)

gg <- ggplot(x, aes(x = car, y = hwy, group = car))
gg <- gg + geom_boxplot() + theme_bw() + xlab("Miles per gallon (highway)")
gg.list[["vertical orientation"]] <- gg

gg.list[["horizontal orientation"]] <- gg + coord_flip()

# ---
# Both figures into a single output figure.

library(cowplot)
plot_grid(gg.list[[1]], gg.list[[2]], rel_widths = c(2, 2.5))
```

[![방향을 변경하면 레이블의 가독성과 데이터의 시각적 해석을 모두 개선할 수 있습니다.](images/principles-orientation.png){fig-alt="방향을 변경하면 레이블의 가독성과 데이터의 시각적 해석을 모두 개선할 수 있습니다. 두 개의 상자 그림이 표시됩니다. 왼쪽에는 상자 그림이 세로형입니다: 축 레이블이 겹치고 시각적 값 비교가 오른쪽보다 어렵습니다. 오른쪽에는 상자 그림이 가로형이고 축 레이블이 이제 분리되어 읽을 수 있습니다."}](images/principles-orientation.png)

### 보조 요소 (Auxiliary elements)

일반적으로 데이터 시각화를 디자인할 때 우리는 Tufte가 "차트 정크(chart junk)"라고 부르는 것, 즉 디스플레이의 정보를 추가하거나 향상시키지 않는 차트의 모든 요소를 경계해야 합니다. 물론 데이터가 쇼의 주인공이므로 가장 많은 공간을 차지해야 합니다. 한편, 모든 추가 요소(선, 색상, 기호 등)는 데이터 해석에 대한 기여도를 평가해야 합니다. 기여도가 없다면 제거할 수 있습니다. 데이터 시각화에서 불필요한 요소의 전형적인 예는 각각 x축과 y축이 있는 5개의 패널(하위 그림 또는 패싯)이 있는 그림입니다. 다른 패널에 표시된 데이터의 효율적인 비교를 허용하기 위해 패널이 모두 한 행에 정렬된 경우 단일 y축이면 충분합니다. 이렇게 하면 데이터를 위한 더 많은 공간이 생기고 부가적인 이점으로 y축 제한과 데이터 위치가 동기화됩니다.

도움이 되는 추가 요소에는 관련 지점의 선이 포함될 수 있습니다. 예를 들어 x=0(예: 시간 0의 경우)의 수직선, y=0(예: 변화 없음 지점을 나타내기 위해)의 수평선 또는 대각선(y=x, 예: x와 y 사이에 차이가 없음을 나타내기 위해)이 있습니다. 보조 요소를 데이터 아래에 그릴지 아니면 위에 그릴지 고려하십시오(일반적으로 그래픽 요소 추가 순서에 따라 다름).

로컬 산점도 평활화(loess, lowess, polynomial)는 제한된 모델 가정으로 관계를 식별하는 데 특히 도움이 될 수 있습니다. 신뢰 대역(점별 신뢰 구간)은 관련된 경우에만 표시해야 합니다.

**예:** 아래 그림은 시작점(시간 0)에서 시간이 지남에 따른 변화를 보여줍니다. 일반 그림(왼쪽 패널)은 독자가 y축 레이블을 읽어 변화 없음 지점(y=0)을 식별해야 합니다. 변화 없음 지점을 나타내는 선을 추가(가운데 패널)하면 읽기가 더 쉬워지고, 변화 없음 지점을 중심으로 대칭인 축 범위를 선택(오른쪽 패널)하면 증가(위쪽 변경)는 시각화의 위쪽 절반에, 감소(아래쪽 변경)는 아래쪽 절반에 할당되어 읽기와 해석이 더 직관적이 됩니다.

```{r}
#| fig-height: 3
# Function for data set generation.
make.data <- function(
    x = c(0, 0.5, 1, 2, 4, 8, 12, 16, 24),
    y = exp(-0.2 * x) - exp(-0.21 * x),
    sd = 0.25, # std dev of y
    seed = 4384590,
    n = 50) {
  # Setting the random number seed for reproducibility.
  set.seed(seed)
  # Creation of x- and y-variables.
  x2 <- rep(x, n)
  y2 <- NULL
  for (i in 1:n) {
    y2 <- c(y2, y * (2 * (n / 4 - i)) + rlnorm(length(y), sd = sd))
  }

  # Creation of an identifier for each profile.
  ID <- factor(rep(1:n, rep(length(y), n)))

  # Composition of the data set.
  df <- data.frame(PD = 100 * y2, time = x, ID = ID)

  # Addition of a baseline variable.
  BL <- df[df$time == 0, c("ID", "PD")]
  names(BL) <- c("ID", "BL")
  df <- merge(df, BL)

  # Addition of change from baseline.
  df$Change <- df$PD - df$BL

  # Definition of treatment.
  df$trt <- ifelse(df$BL > mean(df$BL), "active", " placebo")

  return(df)
}

# Generate the data.
x <- make.data()

# ---
# Figures.

library(ggplot2)
gg <- ggplot(x, aes(x = time, y = Change, group = ID, color = ID))
gg <- gg + theme_bw()
gg <- gg + xlab("Time [h]") + ylab("Change from baseline")
gg <- gg + geom_line(linewidth = 1.1) + theme(legend.position = "none")
gg <- gg + facet_grid(. ~ trt)

# Addition of an auxiliary line at y=0.
gg2 <- gg + geom_hline(yintercept = 0, linewidth = 1.2)

# Symmetric y-axis limits.
gg3 <- gg2 + ylim(c(-1, 1) * max(abs(x$Change)))

# Arranging all plots into one figure.
library(cowplot)
plot_grid(gg, gg2, gg3, nrow = 1)
```

[![변화 없음 지점을 나타내는 선과 같은 요소를 추가하면 가독성을 향상시킬 수 있습니다.](images/principles-auxiliary.png){fig-alt="변화 없음 지점을 나타내는 선과 같은 요소를 추가하면 가독성을 향상시킬 수 있습니다. 이 3부 그림에서 왼쪽 패널은 시간 경과에 따른 변화를 보여주는 선 도표입니다. 가운데 플롯에서는 y축의 기준선(0)을 표시하기 위해 키라인이 추가되었으며, 오른쪽 패널에서는 축 범위가 이 키라인을 중심으로 대칭으로 설정되었습니다."}](images/principles-auxiliary.png)

### 3차원 차트

3차원 데이터 디스플레이는 몇 가지 면에서 눈에 띌 수 있지만, 이러한 프레젠테이션으로 정확한 읽기와 해석은 쉽지 않습니다.

**예:** 아래 그림의 왼쪽 패널은 단일 숫자 10을 3D 막대 차트로 보여줍니다. 값의 올바른 식별은 빨간색 "X"로 표시됩니다. 막대의 높이는 보는 위치에서 뒤쪽 벽(축)에 투영되어야 합니다. 오른쪽 패널은 기울어진 표면에 막대를 배치하여 높이 차이가 없을 때 높이 차이가 있는 것처럼 인식되도록 합니다. 각 행과 열에 동일한 4개의 숫자 10, 20, 30, 40이 표시됩니다.

[![3D 차트에서 데이터 값을 읽는 것은 어렵습니다.](images/principles-3d.png){fig-alt="3D 차트에서 데이터 값을 읽는 것은 어렵습니다. 이 그림의 왼쪽 패널은 단일 숫자 10을 3D 막대 차트로 보여줍니다. 값의 올바른 식별은 이미지 뒤쪽 벽의 빨간색 X로 표시됩니다. 오른쪽 패널은 기울어진 표면에 막대를 배치하여 높이 차이가 없을 때 높이 차이가 있는 것처럼 인식되도록 합니다. 여러 행과 열에 걸쳐 동일한 4개의 숫자 10, 20, 30, 40이 있습니다."}](images/principles-3d.png)

## 표의 요소

표는 그래픽과 마찬가지로 효율적인 시각화 수단이 될 수 있습니다. 또한 제대로 제시되지 않으면 오해를 불러일으키거나 읽기 번거로울 수도 있습니다. 특히 데이터 포인트 수가 적거나 정확한 숫자를 보여줘야 하는 경우 표를 고려해야 합니다. 예를 들어 가독성과 해석을 돕기 위해 그래픽 위에 숫자를 겹쳐서 표시해야 하는 경우(예: 막대 차트의 막대 끝에 숫자 추가), 그래픽을 완전히 생략하고 숫자를 표로 표시하는 것을 고려할 수 있습니다.

표에는 그래픽과 마찬가지로 디자인 요소가 있습니다. 그중 일부는 다음에서 논의됩니다.

### 레이아웃

표의 한 가지 디자인 요소는 레이아웃, 즉 행과 열입니다. 레이아웃은 독자를 염두에 두고 적극적으로 선택해야 합니다. 일반적으로 수평보다 수직으로 숫자를 비교하는 것이 더 쉽습니다.

### 자릿수

자릿수는 표의 행이나 열(즉, 동일한 변수) 내에서는 일관되어야 하지만 변수 간에는 다를 수 있습니다(예: 표에 작은 숫자와 큰 숫자가 포함된 경우). 불필요한 정밀도는 피해야 하며 자릿수를 줄이면 읽기와 비교가 용이해질 수 있습니다.

### 정렬

큰 숫자와 작은 숫자를 쉽게 식별할 수 있도록 숫자는 오른쪽 정렬되어야 합니다. 이렇게 하면 큰 숫자가 말 그대로 튀어나오게 됩니다.

### 표 셀의 여러 숫자

표 셀에 단일 값 이상의 값(예: 평균 및 신뢰 구간)이 포함된 경우 데이터를 쉽게 읽을 수 있도록 표시하는 더 나은 방법이 있는지 고려해야 합니다. 옵션에는 숫자를 여러 표 셀, 행 또는 열로 나누거나 덜 중요한 숫자의 글꼴 크기를 줄이는 것(예: 평균이 신뢰 구간보다 더 중요할 수 있음)이 있습니다.

### 방향

피할 수 없는 경우가 아니라면 가로 방향은 권장하지 않습니다. 일부를 읽기 위해 문서를 회전하는 것은 인쇄물이든 화면이든 독자에게 번거로운 일입니다. 표를 둘로 나누는 것은 가로 방향을 피하는 해결책이 될 수 있지만, 표를 나누는 것이 중요한 비교를 더 어렵게 만드는지 고려해야 합니다.

### 글꼴 및 색상

특정 값을 강조하는 것과 같은 목적에 부합한다면 다른 글꼴과 색상을 사용할 수 있습니다. 장식 목적으로 다른 글꼴이나 색상을 사용하는 것은 권장하지 않습니다.
